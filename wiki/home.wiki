#summary An exception handling framework for C.
#labels Featured

= Introduction =

This library provides you a simple set of keywords (_macros_, actually) which map the semantics of exception handling you're probably already used to:
 * *`try`*
 * *`catch`*
 * *`finally`*
 * *`throw`*

You can write `try/catch/finally` blocks just as if you were coding in Java:

{{{
void * buffer = malloc(1024);
try{
    int bar = foo(buffer);
}finally{
    free(buffer);
}
}}}

A really useful feature is that `finally` blocks are *always* executed, no matter whether exceptions were thrown or not, so you can rely on them to safely dispose resources, deallocate memory and stuff like that.

You can create your own exceptions, so you don't have to deal again with boring error codes, or check return values every time you call a function. Moreover, exceptions can be organized into _pseudo-hierarchies_, so you can catch many specialized exceptions by catching a generic one.

{{{
/*
                 Name                 Description                            Super-exception
*/
DEFINE_EXCEPTION(WhateverException,   "Something went wrong",                RuntimeException);
DEFINE_EXCEPTION(AnimalException,     "An unknown animal ate your keyboard", RuntimeException);
DEFINE_EXCEPTION(SheepException,      "A sheep is laughing at you",          AnimalException);
DEFINE_EXCEPTION(WhiteSheepException, "A white sheep said: Baa!",            SheepException);
DEFINE_EXCEPTION(BlackSheepException, "A black sheep said: Boo!",            SheepException);

try{
    if(foo == bar){
        throw(WhiteSheepException);
    }else{
        throw(BlackSheepException);
    }
}catch(SheepException){
    /* You can catch any kind of SheepException */
    printf("There are evil sheeps in here... (%s)", exception.name);
}catch(WhateverException){
    printf("We know exactly what happened: %s.", exception.description);
}
}}}

As you see, you only need to pass the name of the exception to a `catch` block. The global variable `exception` holds the current exception. You can get its `name`, `description` and `super` _type_. This variable is not `const`, but you should treat it as _read-only_. Also you can _access_ it anywhere you like, but it will only have meaningful values inside `catch` or `finally` blocks.

In addition, signals such as `SIGHUP`, `SIGFPE` and `SIGSEGV` can be handled in an _exceptional_ way. Forget about scary segmentation faults, all you need is to catch `BadPointerException`:

{{{
int * pointer = NULL;
try{
    int oops = *pointer;
}catch(BadPointerException){
    printf("No problem ;-)");
}
}}}

Of course, all these exceptions are _unchecked_, so you rather wrap your application's main loop with a _catch-all_ block if you don't want your application exiting, ahem, _gracefully_ when an exception pops out `main`.

...and that's pretty much it. You might want to play around with *exceptions4c* before actually using it in your projects, but you will realize very soon it's really easy to work with. In order to use exceptions4c you just need to drop the two files (`except4c.h` and `except4c.c`) in your project and remember to include the header file from your code.

Thank you and happy coding!

----

Your comments, opinions, criticism or whatever you have to say about this little framework are very welcome.

<img src='http://exceptions4c.googlecode.com/svn/trunk/etc/sheep_064.png' width='64' height='64' alt='exceptions4c' />