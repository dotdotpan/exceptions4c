#summary Retrying blocks

`retry` repeats the previous `try` or `use` block entirely. 

This macro discards any thrown exception (if any) and repeats the previous `try` (or `use`) block, up to a specified maximum number of attempts. 

This macro is intended to be used in `catch` or `finally` blocks as a quick way to fix an error condition and try again. 

{{{
const char * file_path = config_get_user_defined_file_path();
try{
    config = read_config(file_path);
}catch(ConfigException){
    file_path = config_get_default_file_path();
    retry(1);
    rethrow("Wrong defaults.");
}
}}}

If the specified maximum number of attempts is zero, then the block can eventually be attempted an unlimited number of times. Care must be taken in order not to create an _infinite_ loop. 

This macro won't return control unless the block has already been attempted, at least, the specified maximum number of times. 

At a `catch` block, the current exception is considered caught, whether the `retry` takes place or not. If you want the exception to be propagated when the maximum number of attempts has been reached, then you must throw it again. 

{{{
int dividend = 100;
int divisor = 0;
int result = 0;
try{
    result = dividend / divisor;
    do_something(result);
}catch(RuntimeException){
    divisor = 1;
    retry(1);
    rethrow("Error (not a division by zero).");
}
}}}

At a `finally` block, the current exception (if any) will be propagated if the `retry` does not take place, so you don't need to throw it again. 

{{{
int dividend = 100;
int divisor = 0;
int result = 0;
try{
    result = dividend / divisor;
    do_something(result);
}finally{
    if( e4c_get_status() == e4c_failed ){
        divisor = 1;
        retry(1);
        /* when we get here, the exception will be propagated */
    }
}
}}}


----

[http://exceptions4c.googlecode.com/svn/trunk/etc/exceptions4c_128.png]